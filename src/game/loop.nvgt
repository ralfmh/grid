void game() {
  Map m();
  string definition = file_get_contents("default.map");
  if (definition.is_empty())
  {
    alert("Grid", "Unable to open default.map.");
    return;
  }
  string[] errors = m.Parse(definition);
  if (errors.length() > 0) {
    alert("Validation errors", join(errors,"\n"));
    return;
  }
  m.CreateGrids();
  Person p(0, 0, m);
  Block@[] usedBlocks = m.GetUsedBlocks();
  usedBlocks.insert_last(p.HookBlock);
  BlockSound@[] blockSounds;
  for (int i = 0; i < usedBlocks.length(); i++) {
    blockSounds.insert_last(BlockSound(usedBlocks[i].Material,usedBlocks[i].Type));
  }
  p.FallInterval = DEFAULT_FALL_INTERVAL;
  p.JumpInterval = DEFAULT_JUMP_INTERVAL;
  MoveResult move;
  Direction sonarDirection;
  vector sonarPosition;
  bool sonarEnabled = false;
  sound[] sonarSound(EntityTypes);
  sonarSound[Ladder].load(sounds_directory + "/player/sonar/ladder.ogg");
  sonarSound[None].load(sounds_directory + "/player/sonar/air.ogg");
  sonarSound[Tile].load(sounds_directory + "/player/sonar/tile.ogg");
  sonarSound[Wall].load(sounds_directory + "/player/sonar/wall.ogg");
  EntityType sonarType;
  sound hookSound,hookedSound,unhookSound;
  hookSound.load(sounds_directory + "/player/hook/hook.ogg");
  hookedSound.load(sounds_directory + "/player/hook/hooked.ogg");
  unhookSound.load(sounds_directory + "/player/hook/unhook.ogg");
  int[] hookKeys = { KEY_Q, KEY_W, KEY_E, KEY_A, KEY_S, KEY_D };
  bool wasHooked;
  bool speakText = true;
  string text;
  p.GetText(text);
  speak(text);
  while(true) {
    wait(5);
    wasHooked = p.Hooked;
    if (key_pressed(KEY_ESCAPE)) break;
    if (key_pressed(KEY_C)) {
      speak(p.X+", "+p.Y+(p.LocalMaterial!=""?" on "+p.LocalMaterial:"")
            +", "+AutoMoveStateName[p.AutoMoveState]);
    }
    if(key_pressed(KEY_H)) speak(p.Health+" health");
    if (key_down(KEY_LSHIFT) || key_down(KEY_RSHIFT)) {
      for (int i = 0; i < DIRECTION_KEY.length(); i++) {
        if (key_pressed(DIRECTION_KEY[i])) {
          speak(p.View(Direction(i)));
        }
      }
    }
    else {
      if (key_down(KEY_LEFT)) {
        move = p.Move(Left);
        sonarDirection = Left;
      }
      else if (key_down(KEY_RIGHT)) {
        move = p.Move(Right);
        sonarDirection = Right;
      }
      else if (key_down(KEY_UP)) {
        move = p.Move(Up);
        sonarDirection = Up;
      }
      else if (key_down(KEY_DOWN)) {
        move = p.Move(Down);
        sonarDirection = Down;
      }
    }
    if (key_pressed(KEY_SPACE)) {
      if (p.Jump()) {
        sound_play(sounds_directory+"/player/jump.ogg");
      }
    }
    else if (key_pressed(KEY_F3)) {
      sonarEnabled = !sonarEnabled;
      speak("sonarEnabled " + sonarEnabled);
    }
    else if (key_pressed(KEY_T)) {
      if(key_down(KEY_LSHIFT) || key_down(KEY_RSHIFT)) {
        speakText = !speakText;
        speak("speakText " + speakText);
      }
      else speak(text);
    }
    if (key_down(KEY_LCTRL) || key_down(KEY_RCTRL)) {
      p.ManualMoveInterval = DEFAULT_RUN_INTERVAL;
    }
    else {
      p.ManualMoveInterval = DEFAULT_MOVE_INTERVAL;
    }
    for (int i = 0; i < hookKeys.length(); i++)
    {
      if (key_pressed(hookKeys[i]))
      {
        p.Hook(i < 3 ? Up : Down, i < 3 ? i - 1 : i - 4);
        if (p.Hooked)
        {
          hookSound.play();
          hookedSound.play();
        }
        else
        {
          unhookSound.play();
        }
      }
    }
    if (p.AutoMoveState == Jumping || p.AutoMoveState == Landing)
      p.ManualMoveInterval /= JUMP_SPEEDUP_FACTOR;
    if (p.AutoMoveState == Falling || p.AutoMoveState == Jumping || p.AutoMoveState == Landing) {
      sonarDirection = Down;
    }
    if (sonarEnabled && (move == Moved && p.Sonar(sonarDirection, sonarPosition, sonarType))) {
      sonarSound[sonarType].stop();
      sonarSound[sonarType].set_position_3d(sonarPosition);
      sonarSound[sonarType].play();
    }
    if (move == Moved || p.AutoMoveState != Standing) {
      if (speakText && p.GetText(text)) {
        speak(text);
      }
    }
    if (move == Moved || move == Walled || p.AutoMove()) {
      if (p.Block != null) {
        blockSounds[blockSounds.find(BlockSound(p.Block.Material,p.Block.Type))].PlayStep();
      }
      move = Delayed;
    }
    if (wasHooked && !p.Hooked)
    {
      unhookSound.play();
    }
  }
}