#include "definition.nvgt"
#include "entity.nvgt"

/*
** Represents a 2-dimensional map of tiles and text areas.
*/
final class Map
{
  private string definition;  // The complete map definition.
  
  private Entity@[] entities; // Array of entities.
  
  private int maxX; // The maximum x position of this map.
  
  private int maxY; // The maximum y position of this map.
  
  private grid<int>@ tiles;  // Grid of tiles.
  
  /*
  ** Parses a map definition, fills the entities array and sets
  ** the maximum x and y positions of the map.
  ** Returns an array of validation errors that occurred
  ** while parsing the definition.
  */
  string[] Parse(
    string definition // The complete map definition.
  )
  {
    Entity@ entity;
    string label;
    string[] processedSegments;
    int requiredIndex;
    string[] requiredSegments;
    int typeIndex;
    string[] validationErrors;
    string value;
    this.definition = definition;
    @this.tiles = null;
    this.entities.resize(0);
    this.maxX = 0;
    this.maxY = 0;
    if (definition.empty())
    {
      validationErrors.insert_last("Map is empty.");
      return validationErrors;
    }
    string[] lines = definition.split(LINE_SEPARATOR);
    string[] segments;
    bool lineHasErrors;
    for (int l = 0; l < lines.length(); l++)
    {
      lineHasErrors = false;
      segments = lines[l].split(SEGMENT_SEPARATOR);
      typeIndex = -1;
      for (int t = 0; t < MAP_DEFINITION.length(); t++)
      {
        if (MAP_DEFINITION[t][0] == segments[0])
        {
          typeIndex = t;
          break;
        }
      }
      if (typeIndex == -1)
      {
        validationErrors.insert_last("Unknown type '" + segments[0]
          + "' in line " + (l + 1));
        lineHasErrors = true;
        continue;
      }
      @entity = Entity();
      entity.Type = MAP_DEFINITION[typeIndex][0];
      processedSegments.resize(0);
      requiredSegments = GetRequiredSegments(typeIndex);
      for (int s = 1; s < segments.length(); s++)
      {
        label = segments[s].substr(0, 2);
        if (MAP_DEFINITION[typeIndex].find(1, label) == -1)
        {
          validationErrors.insert_last("Segment '" + label
            + "' is not supported for type '" + MAP_DEFINITION[typeIndex][0]
            + "' in line " + (l + 1));
          lineHasErrors = true;
          break;
        }
        if (processedSegments.find(label) > -1)
        {
          validationErrors.insert_last("Duplicate segment '" + label
            + "' in line " + (l + 1));
          lineHasErrors = true;
        }
        requiredIndex = requiredSegments.find(label);
        if (requiredIndex > -1)
        {
          requiredSegments.remove_at(requiredIndex);
        }
        processedSegments.insert_last(label);
        value = segments[s].substr(2);
        if (value.empty())
        {
          validationErrors.insert_last("The value for segment '" + label
            + "' is missing in line " + (l + 1));
          lineHasErrors = true;
          break;
        }
        if (label != SEGMENT_LV && label != SEGMENT_ML
          && !value.is_digits())
        {
          validationErrors.insert_last("Invalid value '" + value
            + "' for segment '" + label + "' in line " + (l + 1));
          lineHasErrors = true;
          break;
        }
        if (label == SEGMENT_FX)
        {
          entity.FromX = parse_int(value);
        }
        else if (label == SEGMENT_FY)
        {
          entity.FromY = parse_int(value);
        }
        else if (label == SEGMENT_ML)
        {
          entity.Content = value;
        }
        else if (label == SEGMENT_TX)
        {
          entity.ToX = parse_int(value);
        }
        else if (label == SEGMENT_TY)
        {
          entity.ToY = parse_int(value);
        }
        else if (label == SEGMENT_LV)
        {
          break;
        }
      }
      if (!lineHasErrors && requiredSegments.length() > 0)
      {
        string message = "The following segments are missing for type '"
          + MAP_DEFINITION[typeIndex][0] + "' in line " + (l + 1) + ": ";
        for (int i = 0; i < requiredSegments.length(); i++)
        {
          if (i > 0)
          {
            message += ", ";
          }
          message += requiredSegments[i];
        }
        validationErrors.insert_last(message);
        lineHasErrors = true;
      }
      if (lineHasErrors)
      {
        continue;
      }
      if (entity.ToX < entity.FromX)
      {
        validationErrors.insert_last("'tx' may not be less than 'fx' in line "
          + (l + 1));
        break;
      }
      if (entity.ToY < entity.FromY)
      {
        validationErrors.insert_last("'ty' may not be less than 'fy' in line "
          + (l + 1));
        break;
      }
      if (entity.Type == TYPE_TILE)
      {
        entity.ToY = entity.FromY;
      }
      this.entities.insert_last(entity);
      if (entity.Type != TYPE_TEXT)
      {
        if (entity.ToX > this.maxX)
        {
          this.maxX = entity.ToX;
        }
        if (entity.ToY > this.maxY)
        {
          this.maxY = entity.ToY;
        }
      }
    }
    return validationErrors;
  }
  
  /*
  ** Creates the tiles grid.
  */
  void CreateTiles()
  {
    @this.tiles = grid<int>(this.maxX + 1, this.maxY + 1);
    for (int i = 0; i <= this.maxX; i++)
    {
      for (int j = 0; j <= this.maxY; j++)
      {
        this.tiles[i, j] = -1;
      }
    }
    for (int i = 0; i < this.entities.length(); i++)
    {
      if (this.entities[i].Type == TYPE_TEXT)
      {
        continue;
      }
      for (int x = this.entities[i].FromX; x <= this.entities[i].ToX; x++)
      {
        for (int y = this.entities[i].FromY; y <= this.entities[i].ToY; y++)
        {
          this.tiles[x, y] = i;
        }
      }
    }
  }
  
  /*
  ** Gets the tile at a position.
  ** Returns the default tile if none exists at the given position,
  ** or the position lies outside of map boundaries.
  */
  string GetTile(
    int x,  // The x position.
    int y // The y position.
  )
  {
    if (x >= this.tiles.width() || y >= this.tiles.height()
      || this.tiles[x, y] == -1)
    {
      return DEFAULT_TILE;
    }
    return this.entities[this.tiles[x, y]].Content;
  }
}